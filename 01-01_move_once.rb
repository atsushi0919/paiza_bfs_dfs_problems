INPUT1 = <<~"EOS"
  3 3
  1 1
EOS

OUTPUT1 = <<~"EOS"
  .*.
  ***
  .*.
EOS

INPUT2 = <<~"EOS"
  1 1
  0 0
EOS

OUTPUT2 = <<~"EOS"
  *
EOS

def solve(input_str)
  # vx, vy: 方向, step: 歩数
  vy = [1, 0, -1, 0]
  vx = [0, 1, 0, -1]
  step = 1

  # 入力
  h, w, y, x = input_str.split.map(&:to_i)

  # グリッド設定
  grid = Array.new(h) { Array.new(w, ".") }

  # bfs
  queue = [[y, x, step]]
  while not queue.empty?
    # cy: 現在のy, cx: 現在のx, cs: 現在の歩数
    cy, cx, cs = queue.shift
    grid[cy][cx] = "*"
    next if cs == 0

    #️ 現在地の隣接4マスを調べる
    vy.zip(vx).each do |dy, dx|
      # ny: 次のy, nx: 次のx
      ny = cy + dy
      nx = cx + dx

      # 有効範囲外なら追加しない
      next if ny < 0 || ny > h - 1
      next if nx < 0 || nx > w - 1

      # 移動可能なら次の地点を追加
      queue << [ny, nx, cs - 1]
    end
  end
  # グリッドを返す
  grid.map { |l| l.join }.join("\n")
end

p solve(INPUT1)

=begin
1 マスの移動 (paizaランク C 相当)
問題にチャレンジして、ユーザー同士で解答を教え合ったり、コードを公開してみよう！

シェア用URL:
https://paiza.jp/works/mondai/bfs_dfs_problems/bfs_dfs_problems__move_once
問題文のURLをコピーする
 下記の問題をプログラミングしてみよう！
グリッドの行数 H と列数 W が与えられるので、
マス (y,x) から次の移動を 1 回おこなった時に到達することができるマスを '*' , 
それ以外のマスを '.' にしたグリッドを出力してください。

・現在いるマスを (y,x) としたとき、(y+1,x), (y-1,x), (y,x+1), (y,x-1) のいずれかのマスに移動する。

ただし、グリッドの外へは移動することができません。
なお、グリッドの左上・右上・左下・右下のマスをそれぞれ (0,0), (0,W-1), (H-1,0), (H-1,W-1) とします。
到達できるマスに (y,x) が含まれることに気をつけてください。

▼　下記解答欄にコードを記入してみよう

入力される値
H W
y x


・ 1 行目では、グリッドの行数 H , 列数 W が半角スペース区切りで与えられます。
・ 2 行目では、移動を開始するマスの座標を表す y, x が半角スペース区切りで与えられます。

入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
期待する出力
H 行の出力

・マス (y,x) から前後左右に 1 マス移動して到達することができるマスを '*' , それ以外のマスを '.' にしたグリッドを出力してください。
・グリッドの行ごとに改行区切りで出力してください。
・詳しくは入力例を参考にしてください。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・1 ≦ H, W ≦ 10
・0 ≦ y < H
・0 ≦ x < W

入力例1
3 3
1 1

出力例1
.*.
***
.*.

入力例2
1 1
0 0

出力例2
*
=end
